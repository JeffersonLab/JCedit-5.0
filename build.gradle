/*
 * Copyright (c) 2017.  Jefferson Lab (JLab)...
 */

plugins {
    id 'java-library'
    id 'maven-publish'
    // id 'checkstyle'
    id 'com.github.spotbugs' version '5.2.5'
    id 'eclipse'
    id 'idea'
}

group = 'org.jlab.coda'
version = '5.0-SNAPSHOT'

base {
    archivesName = 'jcedit'
}

defaultTasks 'build'

configurations {
    all {
        resolutionStrategy.cacheChangingModulesFor 30, 'minutes'
    }
    deployerJars
}

sourceSets {
    main {
        java { srcDir 'src' }
    }
    test {
        java {
            srcDir 'test'
            exclude "resources/**"
        }
        resources { srcDir 'test/resources' }
    }
}

repositories {
    mavenCentral()
}

dependencies {
    // JAXB and other dependencies
    implementation 'jakarta.xml.bind:jakarta.xml.bind-api:2.3.3'
    runtimeOnly 'org.glassfish.jaxb:jaxb-runtime:2.3.3'
    implementation 'org.apache.jena:jena-core:4.6.0'
    implementation 'org.apache.jena:jena-arq:4.6.0'
    implementation 'org.yaml:snakeyaml:1.18'
    api 'org.json:json:20160810'
    api 'org.jline:jline:3.1.3'
    implementation 'org.apache.commons:commons-exec:1.3'
    implementation 'org.freemarker:freemarker:2.3.26-incubating'
    implementation 'net.sf.jopt-simple:jopt-simple:4.9'
    implementation 'com.google.code.findbugs:jsr305:3.0.1'
    implementation 'junit:junit:4.12'
    deployerJars 'org.apache.maven.wagon:wagon-ssh-external:2.12'
    testImplementation 'org.junit.jupiter:junit-jupiter:5.4.2'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.4.2'
    testImplementation 'org.hamcrest:hamcrest-library:1.3'
    testImplementation 'org.mockito:mockito-junit-jupiter:2.28.2'
}

java {
    withSourcesJar()
    withJavadocJar()

    // Compile for Java 11
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11

    // Ensure a Java 11 toolchain is used (portable across machines)
    toolchain {
        languageVersion = JavaLanguageVersion.of(11)
    }
}

jar {
    manifest {
        attributes 'Main-Class': 'org.jlab.coda.cedit.cooldesktop.CDesktopNew'
    }
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    from('src/resources') {
        into 'resources'
    }
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

compileJava {
    // Remove --release 17; use 11
    options.release = 11
}

javadoc {
    options.charSet = 'utf8'
    options.encoding = 'utf8'
    options.docEncoding = 'utf8'
    options.addStringOption('Xdoclint:none', '-quiet')
    include "org/jlab/coda/cedit/**"
}

publishing {
    publications {
        maven(MavenPublication) {
            // NOTE: original had a likely typo 'org.jalb...'
            groupId = 'org.jlab.coda.cedit'
            artifactId = 'library'
            version = '5.0'
            from components.java
        }
    }
}

test {
    useJUnitPlatform {
        excludeTags 'integration'
    }
    testLogging { exceptionFormat = 'full' }
}

tasks.register('integrationTest', Test) {
    useJUnitPlatform {
        includeTags 'integration'
    }
    testLogging { exceptionFormat = 'full' }
    testClassesDirs = testing.suites.test.sources.output.classesDirs
    classpath = testing.suites.test.sources.runtimeClasspath
    outputs.upToDateWhen { false }
}

tasks.withType(JavaCompile).configureEach {
    options.compilerArgs << "-Xlint:deprecation"
}

//////////////////////////////////////////////////////////////////////////////
// version information
//////////////////////////////////////////////////////////////////////////////

def runGit(cmd) {
    rootProject.file('.git').exists() ? cmd.execute().text.trim() : ''
}

ext {
    gitBranch = properties['gitBranch'] ?: runGit('git rev-parse --abbrev-ref HEAD')
    gitRev = properties['gitRev'] ?: runGit('git rev-parse --short=10 HEAD')
    gitDescribe = properties['gitDescribe'] ?: runGit('git describe --match=v[0-9]* --abbrev=10 HEAD')
}

tasks.register('generateVersionProperties') {
    def propertiesFile = file("${buildDir}/resources/main/META-INF/version.properties")

    inputs.property 'version', project.version
    inputs.property 'groupId', project.group
    inputs.property 'artifactId', project.base.archivesName
    inputs.property 'gitBranch', gitBranch
    inputs.property 'gitRev', gitRev
    inputs.property 'gitDescribe', gitDescribe
    outputs.file propertiesFile

    doLast {
        propertiesFile.write "version=${project.version}\n"
        propertiesFile.append "groupId=${project.group}\n"
        propertiesFile.append "artifactId=${project.base.archivesName}\n"
        propertiesFile.append "builtBy=${System.getProperty('user.name')}\n"
        propertiesFile.append "builtJDK=${System.getProperty('java.version')}\n"

        if (gitBranch) {
            propertiesFile.append "git.branch=${gitBranch}\n"
        }
        if (gitRev) {
            propertiesFile.append "git.revision=${gitRev}\n"
        }
        if (gitDescribe) {
            propertiesFile.append "git.describe=${gitDescribe}\n"
        }
    }
}

classes.dependsOn generateVersionProperties

//////////////////////////////////////////////////////////////////////////////
// deployment
//////////////////////////////////////////////////////////////////////////////

def deploySpec = copySpec {
    // your deployment spec (kept commented as in original)
}

tasks.register('distSources', Tar) {
    archiveExtension = 'tar.gz'
    archiveClassifier = 'src'
    compression = Compression.GZIP

    into "${archiveBaseName.get()}-${archiveVersion.get()}-${archiveClassifier.get()}"

    from 'README.md'
    from 'build.gradle'
    from 'settings.gradle'
    from 'gradlew'
    from 'gradlew.bat'

    def sourceDirs = ['config','gradle','scripts','src','test']
    sourceDirs.each { dir -> from ("${dir}") { into "${dir}" } }

    dependsOn build
}

tasks.register('distBinaries', Tar) {
    archiveExtension = 'tar.gz'
    compression = Compression.GZIP
    into "${archiveBaseName.get()}-${archiveVersion.get()}"
    with deploySpec
    dependsOn build
}

tasks.register('deploy', Copy) {
    def dest = "$System.env.CODA/common/jar"
    into dest
    with deploySpec
    doFirst {
        if (dest == 'null') {
            throw new GradleException('CODA env is not set')
        }
    }
    dependsOn jar
}

//////////////////////////////////////////////////////////////////////////////
// development scripts
//////////////////////////////////////////////////////////////////////////////

ext {
    classPathCache = file("${buildDir}/tmp/classpath")
    testClassPathCache = file("${buildDir}/tmp/test_classpath")
}

tasks.register('cacheClasspath') {
    inputs.files sourceSets.main.runtimeClasspath
    inputs.files sourceSets.test.runtimeClasspath
    outputs.files classPathCache
    outputs.files testClassPathCache
    doLast {
        classPathCache.write sourceSets.main.runtimeClasspath.asPath
        testClassPathCache.write sourceSets.test.runtimeClasspath.asPath
    }
}

tasks.register('printClasspath') {
    doLast {
        println classPathCache.text.replace(':', '\n')
    }
    dependsOn cacheClasspath
}

assemble.dependsOn cacheClasspath

//////////////////////////////////////////////////////////////////////////////
// quality check
//////////////////////////////////////////////////////////////////////////////

ext { ciMode = properties['ciMode'] ?: 'false' }

//checkstyle {
//    toolVersion = '10.15.0'
//    configFile = file('config/quality/checkstyle.xml')
//    configProperties['samedir'] = file('config/quality')
//}

spotbugs {
    toolVersion = '4.8.3'
    ignoreFailures = true
    effort = 'max'
    reportLevel = 'medium'
    excludeFilter = file('config/quality/findbugs-exclude.xml')
}

tasks.withType(com.github.spotbugs.snom.SpotBugsTask) {
    def useXml = ciMode.toBoolean()
    reports {
        xml.enabled = useXml
        html.enabled = !useXml
    }
}

tasks.register('checkSpotBugsResults') {
    doLast {
        def bugsFound = 0
        [spotbugsMain, spotbugsTest].each {
            try {
                bugsFound += printSpotBugs it.reports.getByName('xml').destination
            } catch (FileNotFoundException e) {
                logger.info e.message
            }
        }
        if (bugsFound > 0) {
            throw new GradleException("$bugsFound SpotBugs rule violations were found.")
        }
    }
}

def printSpotBugs(File xml) {
    def slurped = new XmlSlurper().parse(xml)
    def bugs = slurped.BugInstance
    bugs.each { bug ->
        def line = bug.SourceLine
        logger.error "[SpotBugs] ${line.@sourcepath}:${line.@start}:${line.@end} [${bug.@type}]"
    }
    bugs.size()
}

tasks.register('spotbugs') {
    group = 'Verification'
    description = 'Marker task to enable SpotBugs.'
    mustRunAfter spotbugsMain, spotbugsTest
    if (ciMode.toBoolean()) {
        finalizedBy checkSpotBugsResults
    }
}

gradle.taskGraph.whenReady { taskGraph ->
    tasks.spotbugsMain.onlyIf { taskGraph.hasTask(tasks.spotbugs) }
    tasks.spotbugsTest.onlyIf { taskGraph.hasTask(tasks.spotbugs) }
    tasks.checkSpotBugsResults.onlyIf { taskGraph.hasTask(tasks.spotbugs) }
}

//////////////////////////////////////////////////////////////////////////////
// IDE configuration
//////////////////////////////////////////////////////////////////////////////

eclipse {
    classpath {
        file {
            defaultOutputDir = file("${buildDir}/eclipse")
            whenMerged { classpath ->
                classpath.entries.each { source ->
                    if (source.kind == 'src' && source.hasProperty('output')) {
                        source.output = "${buildDir.getName()}/eclipse"
                    }
                }
            }
        }
    }
}
